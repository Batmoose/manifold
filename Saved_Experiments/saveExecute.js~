module.exports = Processor;
function Processor(){
    this.save = {
        init: function(fileInfo){
            this.body = "";
            this.finished = false;
            if(fileInfo.filename){
                
            }
            this.fileType = fileInfo.fileType ||
                fileInfo.filename.slice(0, fileInfo.filename.lastIndexOf('.')) ||
                'txt';
            this.filename = fileInfo
            this.filename = fileInfo.filename || "untitled" + Date();
            if(!){
                this.filePath = this.fileName = undefined;
                this.fileType = contentType || undefined;
            }else{
                if(contentType){ //Specified contentType overrides EVERYTHING ELSE
                    this.fileType = contentType;
                    this.fileName = (extensionType === contentType ? 
                        filename.slice(0, filename.lastIndexOf('.')) : //Everything before the extension
                        filename) + //Include the extension since it's NOT recongnized and therefore part of filename
                        "." + (mime.extension(contentType) || ".txt"); //append a content-type appropriate extension, or default
                }else if(extensionType){ //An extension at the end of the filename is second best
                    this.fileType = extensionType;
                    this.fileName = filename;
                }else{ //Default if niether of above cases succeed
                    this.fileType = 'text/plain';
                    this.fileName = filename;
                }
                this.filePath = path.normalize(__dirname + '/' + this.fileName); // should be ready to use
                console.log("MAH FILEPATH: " + this.filePath);
            }
            delete this.init;
        }
    };
};
Processor.prototype.manageUpload = function(s, e){
    var headerMatch = function(headerText, matchText){
        return this.req.headers[headerText] && this.req.headers[headerText].indexOf(matchText) > -1;
    };
    var self = this,
    fs = require('fs'), fileCases = {
        /*handle : new ManageCases(this),
        choose : function(val, args){
            this.handle.choose(val, args);
        },*/
        callback : function(){
        console.log(self.upload.filePath);
            fs.exists(self.upload.filePath, function(exists){
                return exists ? choose(fileCases.exists) :
                choose(fileCases.noMatch);
            });
        }
    };
    fileCases.exists = {
        callback : function(){
            console.log('file exists');
            if(headerMatch('if-match', self.upload.fileName)){
                choose(fileCases.writeOk);
            }else if(headerMatch('if-none-match', self.upload.fileName))
                e('PRECONDITION_FAILED');
            else
                e('CONFLICT');
        }
    };
    fileCases.noMatch = {
        callback : function(){
            if(headerMatch('if-match', self.upload.fileName))
                e('PRECONDITION_FAILED');
            else {
                choose(fileCases.writeOk);
            }
        }
    };
    fileCases.writeOk = {
        callback : function(){
            req.on('end', fileCases.writeOk.uploadReceived.callback); //safety net
            if(continueExpect && !self.upload.finished){
                req.removeListener('end', fileCases.writeOk.uploadReceived.callback);
                choose(fileCases.writeOk.uploadPipe);
            }else if(self.upload.finished){
                req.removeListener('end', fileCases.writeOk.uploadReceived.callback);
                choose(fileCases.writeOk.uploadReceived);
            }
        }
    };
    fileCases.writeOk.uploadPipe = {
        callback : function(){
            var ws = fs.createWriteStream(self.upload.filePath);
            ws.write(self.upload.body); //write what was already uploaded (just in case)
            self.req.on('data', function(chunk){
                var written = ws.write(chunk);
                if(!written){
                    self.req.pause(); //wait for buffer to clear
                    ws.once('drain', function(){
                        self.req.resume(); //resume when buffer cleared
                        ws.write(chunk);
                    });
                }
            });
            ws.on('error', function(exception){
                ws.destroy();
                e('INTERNAL_SERVER_ERROR');
            });
            ws.on('end', function(){
                ws.destroySoon();
                e('201');
            });
            self.req.on('end', function(){
                ws.end();
            });
            s('100'); // client 'should' send body after
        }
    };
    fileCases.writeOk.uploadReceived = {
        callback : function(){
            fs.writeFile(self.upload.filePath,
                self.upload.body,
                function(err){
                    e('INTERNAL_SERVER_ERROR');
                });
            s('201');
        }
    };
    
    return fileCases.callback();
    
    function choose(obj, args){
        return obj.callback.apply(obj, args); /*|| findCallback();
        function findCallback(){
            for (var i in obj){
                if(typeof obj[i] == 'function'){
                    return obj[i].apply(obj[i], args);
                }
            }
            new Err('noCallback');
        }*/
    }
};
Processor.prototype.executeExperiment = function(dir, flags, s, e){
      var sessionEmitter = new Event();
      var exe = function(socket){
          var executor = require('./utils/executor2.js');
          console.log('EVERYTHING WORKS!!!');
          executor.setEmitter(socket);
          var exp = executor.execute(dir, function(m){
              s(m);
          },
          function(error){
              e('500');
          }, flags);
      };
      console.log(internalEmitter.listeners);
      internalEmitter.on('newListener', function(){
          if(internalEmitter.listeners('setEmitter')){
              internalEmitter.emit('setEmitter', sessionEmitter);
          }
      });
      if(internalEmitter.listeners('setEmitter')){
          console.log('WHENASDASD');
          internalEmitter.emit('setEmitter', sessionEmitter);
      }
      sessionEmitter.emit('proceed', exe);
      //must be called first
      /*console.log('do we even get here');
      state.on('expError', function(m){
          internalEmitter.once('socket', function(socket){
              socket.emit('expError', m);
          });d
      });
      state.on('setNew', function(m){
          internalEmitter.once('socket', function(socket){
              state.on(m, function(a){
                  socket.emit(m, a);
              });
              socket.emit('setNew', m);
              console.log('new set');
          });
      });
      internalEmitter.once('socket', function(socket){
          socket.on('instruction', function(i){
              exp.send({'instruction': i});
          });
      });*/
};
